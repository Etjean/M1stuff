pockets.dat = read.table("descriptor_pocket.mat")
pockets.dat = na.omit(pockets.dat)
aromatic = apply(pockets.dat[,c("F","Y","H","W")],1,sum)
polar = apply(pockets.dat[,c("C","D","E","H","K","N","Q","R","S","T","W","Y")],1,sum)
aliphatic = apply(pockets.dat[,c("I","L","V")],1,sum)
charged = apply(pockets.dat[,c("D","E","R","K","H")],1,sum)
negative = apply(pockets.dat[,c("D","E")],1,sum)
positive = apply(pockets.dat[,c("H","K","R")],1,sum)
hydrophobic = apply(pockets.dat[,c("C","G","A","T","V","L","I","M","F","W","Y","H","K")],1,sum)
small = apply(pockets.dat[,c("C","V","T","G","A","S","D","N","P")],1,sum)
tiny = apply(pockets.dat[,c("F","Y","H","W")],1,sum)
pockets.dat = cbind(pockets.dat[,-28], aromatic, polar, aliphatic, charged, negative, positive, hydrophobic, small, tiny, drugg=pockets.dat[,28])
matAppTest <- function(myData, output = c(TRUE, FALSE)) {
if(missing(ouptut)) { output = F }
# Spliting procedure
vIndApp <- sample(1:nrow(myData), nrow(myData)*(2/3), replace=F)
vIndTest <- (1:nrow(myData))[-vIndApp]
matApp <- pockets.dat[vIndApp,]
matTest <- pockets.dat[vIndTest,]
results <- list(matApp, matTest)
# Output
if(output) {
write.table(matApp, file="matApp.csv")
write.table(matTest, file="matTest.csv")
}
return(results)
}
res1 <- matAppTest(pockets.dat, T)
pockets.dat = read.table("descriptor_pocket.mat")
pockets.dat = na.omit(pockets.dat)
aromatic = apply(pockets.dat[,c("F","Y","H","W")],1,sum)
polar = apply(pockets.dat[,c("C","D","E","H","K","N","Q","R","S","T","W","Y")],1,sum)
aliphatic = apply(pockets.dat[,c("I","L","V")],1,sum)
charged = apply(pockets.dat[,c("D","E","R","K","H")],1,sum)
negative = apply(pockets.dat[,c("D","E")],1,sum)
positive = apply(pockets.dat[,c("H","K","R")],1,sum)
hydrophobic = apply(pockets.dat[,c("C","G","A","T","V","L","I","M","F","W","Y","H","K")],1,sum)
small = apply(pockets.dat[,c("C","V","T","G","A","S","D","N","P")],1,sum)
tiny = apply(pockets.dat[,c("F","Y","H","W")],1,sum)
pockets.dat = cbind(pockets.dat[,-28], aromatic, polar, aliphatic, charged, negative, positive, hydrophobic, small, tiny, drugg=pockets.dat[,28])
matAppTest <- function(myData, output = c(TRUE, FALSE)) {
if(missing(ouptut)) { output = F }
# Spliting procedure
vIndApp <- sample(1:nrow(myData), nrow(myData)*(2/3), replace=F)
vIndTest <- (1:nrow(myData))[-vIndApp]
matApp <- pockets.dat[vIndApp,]
matTest <- pockets.dat[vIndTest,]
results <- list(matApp, matTest)
# Output
if(output) {
write.table(matApp, file="matApp.csv")
write.table(matTest, file="matTest.csv")
}
return(results)
}
res1 <- matAppTest(pockets.dat, T)
matAppTest <- function(myData, output = c(TRUE, FALSE)) {
if(missing(output)) { output = F }
# Spliting procedure
vIndApp <- sample(1:nrow(myData), nrow(myData)*(2/3), replace=F)
vIndTest <- (1:nrow(myData))[-vIndApp]
matApp <- pockets.dat[vIndApp,]
matTest <- pockets.dat[vIndTest,]
results <- list(matApp, matTest)
# Output
if(output) {
write.table(matApp, file="matApp.csv")
write.table(matTest, file="matTest.csv")
}
return(results)
}
res1 <- matAppTest(pockets.dat, T)
matApp <- res1[[1]]
matTest <- res1[[2]]
# Samples variables comparison
#par(mfrow=c(2,1))
#for (i in 1:ncol(matApp)) {
#	hist(matApp[,i], main = colnames(matApp)[i])
#  hist(matTest[,i], main = colnames(matTest)[i])
#}
matKFold <- function(matApp, k) {
if(k < 2 || floor(k) != k) { stop("argument \"k\" must be an integer greater than 1.") }
results <- list()
for(i in 1:k) {
vInd <- sample(1:nrow(matApp), nrow(matApp)*(1/(k-i+1)), replace=F)
results[[i]] <- matApp[vInd,]
matApp <- matApp[-vInd,]
}
return(results)
}
res2 <- matKFold(matApp, 5)
crossValidation <- function(matKFold) {
if(length(matKFold) < 2) { stop("argument \"k\" must be an integer greater than 1.") }
for(i in 1:length(matKFold)) {
# Splitting
matApp <- do.call("rbind",matKFold[c(-i)])
matTest <- matKFold[[i]]
# Test
}
}
crossValidation(res2)
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(cars)
pockets = read.table("descriptor_pocket.mat")
names(pockets)
dim(pockets)
#is.na(pockets)
pockets = na.omit(pockets)
dim(pockets)
aromatic = apply(cbind(pockets$F, pockets$Y, pockets$H, pockets$W), 1, sum)
polar = apply(cbind(pockets$C, pockets$D, pockets$E, pockets$H, pockets$K, pockets$N, pockets$Q, pockets$R, pockets$S, pockets$T, pockets$W, pockets$Y), 1, sum)
aliphatic = apply(cbind(pockets$I, pockets$L, pockets$V), 1, sum)
charged = apply(cbind(pockets$D, pockets$E, pockets$R, pockets$K, pockets$H), 1, sum)
negative = apply(cbind(pockets$D, pockets$E), 1, sum)
positive = apply(cbind(pockets$R, pockets$K, pockets$H), 1, sum)
hydrophobic = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$L, pockets$I, pockets$M, pockets$F, pockets$W, pockets$H, pockets$Y, pockets$K), 1, sum)
small = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$S, pockets$D, pockets$N, pockets$P), 1, sum)
tiny = apply(cbind(pockets$A, pockets$C, pockets$G, pockets$S), 1, sum)
pockets = cbind(pockets, aromatic, polar, aliphatic, charged, negative, positive, hydrophobic, small, tiny)
#mise de "drugg" à la fin du tableau
noms = names(pockets)
pockets = cbind(pockets[,1:27], pockets[,29:37], pockets[,28])
colnames(pockets)[37] = noms[28]
names(pockets)   #37 descriptors
boxplot(scale(pockets[,-37]), las=2)
#ma version
hist(pockets$polar[pockets$drugg == 1], freq=F, col = "purple", xlim = c(0, 1))
hist(pockets$polar[pockets$drugg == 0], freq=F, col =rgb(1,0,0,0.5), add=T)
#version prof
# par(mfrow = c(1, 2))
# for (i in c(1:36))
#     by(pockets[,i], pockets$drugg, hist, main = "un histogramme")
#ma version
# for (i in 1:36){
#     print(mean(pockets[,i][pockets$drugg == 1]))
#     print(mean(pockets[,i][pockets$drugg == 0]))
#     print(sd(pockets[,i][pockets$drugg == 1]))
#     print(sd(pockets[,i][pockets$drugg == 0]))
# }
#version prof
# lapply(pockets, mean)
# lapply(pockets, sd)
print(means <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = mean))
print(sds <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = sd))
pockets.pvalues = c()
for (i in 1:36){
# Optionnel, il faudrait comparer les variances, comme condition d'application du Student
#    var.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])
pvalue = t.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])$p.value
pockets.pvalues = c(pockets.pvalues, pvalue)
}
pockets.pvalues
# drug.corr = cor(pockets[,-37])
# library(corrplot)
# corrplot(drug.corr)
# plot(pockets$polar, pockets$hydrophobic)
# plot(pockets$Real_volume, pockets$C_ATOM)
pockets.dist = dist(scale(pockets[,-37]))
# donne un matrice triangulaire inférieure de la distance de tous les résidus 2 à 2
pockets.tree = hclust(pockets.dist, method = "ward.D2")
plot(pockets.tree, hang=-1, labels = pockets$drugg, xlab = "Poches (1 = druggable, 0 = non-druggable)", ylab = "Distance", main = "Dendrogramme par la m?thode de Ward")
rect.hclust(pockets.tree, k = 5, border = "red")
# rect.hclust(pockets.tree, k = 6, border = "red")
# rect.hclust(pockets.tree, k = 8, border = "red")
pockets.kmeans = kmeans(pockets[, -37], centers = 3)
pockets.kmeans$cluster
plot(hclust(pockets.dist), hang = -1, labels = as.factor(pockets.kmeans$cluster))
I.intra = rep(0, 10)
I.intra
for (i in 1:length(I.intra)){
I.intra[i] = kmeans(pockets, centers = i)$tot.withinss
}
plot(I.intra, type = "l", xlab = "Nombre de clusters", ylab = "Inertie intra-classe", main = "D?termination du nombre de cluster id?al par la m?thode des kmeans")
abline(v=3, col = "red")
text(3, 40000000, "3 clusters", col = "red")
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp$eig))
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp12$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp$eig))
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp12$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp12$eig))
barplot(pockets.acp12$eig[,3], main="Somme cumulé des variances")
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(pockets.acpclusters, choix = "ind", col.ind = pockets.kmeans$cluster)
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(pockets.acp12, choix = "ind", col.ind = pockets.kmeans$cluster)
print(sample(pockets, 2/3*length(pockets), replace=F))
print(sample(pockets, 2/3*length(pockets), replace=F))
print(sample(nrow(pockets), 2/3*length(pockets), replace=F))
print(sample(1:nrow(pockets), 2/3*length(pockets), replace=F))
print(pockets[sample(nrow(pockets), 2/3*length(pockets), replace=F)),])
print(pockets[sample(nrow(pockets), 2/3*length(pockets), replace=F),])
print(pockets[sample(nrow(pockets), 2/3*nrow(pockets), replace=F),])
print(pockets[sample(nrow(pockets), 2/3*nrow(pockets), replace=F),])
print(pockets[sample(nrow(pockets), 1/3*nrow(pockets), replace=F),])
print(pockets[sample(nrow(pockets), 2/3*nrow(pockets), replace=F),])
print(pockets[sample(nrow(pockets), 1/3*nrow(pockets), replace=F),])
print(pockets[sample(nrow(pockets), round(2/3*nrow(pockets)), replace=F),])
print(pockets[sample(nrow(pockets), round(1/3*nrow(pockets)), replace=F),])
pockets.lrn = pockets[sample(nrow(pockets), round(2/3*nrow(pockets)), replace=F),]
pockets.tst = pockets[sample(nrow(pockets), round(1/3*nrow(pockets)), replace=F),]
index = sample(nrow(pockets), round(2/3*nrow(pockets)), replace=F)
pockets.lrn = pockets[index,]
pockets.tst = pockets[-index,]
k = 4
#Division of the learning sample into k parts
pockets.kparts = c()
pockets.rest = pockets.lrn
for (i in 1:k) {
index.k = sample(nrow(pockets.rest), round(1/k*nrow(pockets.lrn)), replace=F)
pockets.kparts = c(pockets.kparts, pockets.rest[index.k])
pockets.rest = pockets.rest[-index.k,]
}
k = 4
#Division of the learning sample into k parts
pockets.kparts = c()
pockets.rest = pockets.lrn
for (i in 1:k) {
index.k = sample(nrow(pockets.rest), round(1/(k-i+1)*nrow(pockets.rest)), replace=F)
pockets.kparts = c(pockets.kparts, pockets.rest[index.k])
pockets.rest = pockets.rest[-index.k,]
}
k = 4
#Division of the learning sample into k parts
pockets.kparts = c()
pockets.rest = pockets.lrn
for (i in 1:k) {
index.k = sample(nrow(pockets.rest), round(1/(k-i+1)*nrow(pockets.rest)), replace=F)
pockets.kparts = c(pockets.kparts, pockets.rest[index.k,])
pockets.rest = pockets.rest[-index.k,]
}
print(pockets.kparts)
k = 4
#Division of the learning sample into k parts
pockets.kparts = c()
pockets.rest = pockets.lrn
for (i in 1:k) {
index.k = sample(nrow(pockets.rest), round(1/(k-i+1)*nrow(pockets.rest)), replace=F)
pockets.kparts = c(pockets.kparts, pockets.rest[index.k,])
pockets.rest = pockets.rest[-index.k,]
}
print(dim(pockets.kparts))
