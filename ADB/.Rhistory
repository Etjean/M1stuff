gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
dt.x = dt.x[,elimcor_sansY(dt.x, s=0.8)$possetap]
dim(dt.x)
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
dt.x = dt.x[,elimcor_sansY(dt.x, s=0.8)$possetap]
dim(dt.x)
knitr::opts_chunk$set(echo = TRUE)
dt = read.table("herg.txt", sep='\t', header=T, row.names=NULL)
dt = na.omit(dt)
print(dim(dt))
dt.y = dt[,1:5]
dt.x = dt[,6:ncol(dt)]
dt.x.sd_of_descriptors = apply(dt.x, 2, sd)
dt.x = dt.x[,-which(dt.sd_of_descriptors == 0)]
dt.x = dt.x[-which(dt.y$IC50 > 500),]
dt.y = dt.y[-which(dt.y$IC50 > 500),]
print(dim(dt.x))
hist(dt.y$IC50)
hist(scale(log(dt.y$IC50)))
library(FactoMineR)
dt.x.pca = PCA(dt.x, ncp=5, axes=c(1,2), graph=T)
cor(dt.y$IC50, dt.x[,1])
cor(dt.y$IC50, dt.x[,10])
cor(dt.y$IC50, dt.x[,92])
#Best correlation for activity vs D10
lsfitD10 = lsfit(dt.y$IC50, dt.x[,10])
plot(dt.y$IC50, dt.x[,10])
abline(lsfitD10, col="red")
library(corrplot)
dt.x.cor = cor(dt.x[,1:10])
corrplot(dt.x.cor)
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
dt.x = dt.x[,elimcor_sansY(dt.x, s=0.8)$possetap]
dim(dt.x)
splitting_lrn_tst <- function(data) {
#return lrn, tst
index = sample(nrow(dt.x), round(2/3*nrow(dt.x)), replace=F)
return(c(data[index,], data[-index,]))
}
dt.x.lrn, dt.x.tst = splitting_lrn_tst(dt.x)
splitting_lrn_tst <- function(data) {
#return lrn, tst
index = sample(nrow(dt.x), round(2/3*nrow(dt.x)), replace=F)
return(c(data[index,], data[-index,]))
}
dt.x.lrn = splitting_lrn_tst(dt.x)[1]
dt.x.tst = splitting_lrn_tst(dt.x)[2]
dt.y.lrn = splitting_lrn_tst(dt.x)[1]
dt.y.tst = splitting_lrn_tst(dt.x)[2]
index = sample(nrow(dt.y), round(2/3*nrow(dt.y)), replace=F)
dt.x.lrn = dt.x[index,]
dt.x.tst = dt.x[-index,]
dt.y.lrn = dt.y[index,]
dt.y.tst = dt.y[-index,]
lm(dt.y.lrn$IC50 ~ dt.x.lrn)
lm(dt.y.lrn$IC50 ~ list(dt.x.lrn))
lm(dt.y.lrn$IC50 ~ dt.x.lrn)
lm(dt.y.lrn$IC50 ~ ., data = dt.x.lrn)
lm.lrn = lm(dt.y.lrn$IC50 ~ ., data = dt.x.lrn)
summary(lm.lrn)
lm.lrn = lm(dt.y.lrn$IC50 ~ ., data = dt.x.lrn)
lm.lrn
lm.lrn = lm(dt.y.lrn$IC50 ~ dt.x.lrn)
lm.lrn = lm(dt.y.lrn$IC50 ~ ., data = dt.x.lrn)
lm.lrn
step(lm)
step(lm.lrn)
step(lm.lrn)$coefficients
summary(step(lm.lrn))
step.lrn = step(lm.lrn)
step.lrn <- step(lm.lrn)
step.lrn <- step(lm.lrn)
summary(step.lrn)
step.lrn
dim(step.lrn)
length(step.lrn)
predict(lm.lrn)
predict(lm.lrn)
predict(step.lrn)
predict(lm.lrn)
predict(step.lrn)
predict(step.lrn, dt.x.tst)
predict(lm.lrn, dt.x.tst)
predict(step.lrn, dt.x.tst)
hist(dt.y.tst$IC50 - pred.lm)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
mean(dt.y.tst$IC50 - pred.lm)
sd(dt.y.tst$IC50 - pred.lm)
mean(dt.y.tst$IC50 - pred.step)
sd(dt.y.tst$IC50 - pred.step)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
mean(dt.y.tst$IC50 - pred.lm)
sd(dt.y.tst$IC50 - pred.lm)
mean(dt.y.tst$IC50 - pred.step)
sd(dt.y.tst$IC50 - pred.step)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
knitr::opts_chunk$set(echo = TRUE)
dt = read.table("herg.txt", sep='\t', header=T, row.names=NULL)
dt = na.omit(dt)
print(dim(dt))
dt.y = dt[,1:5]
dt.x = dt[,6:ncol(dt)]
dt.x.sd_of_descriptors = apply(dt.x, 2, sd)
dt.x = dt.x[,-which(dt.sd_of_descriptors == 0)]
knitr::opts_chunk$set(echo = TRUE)
dt = read.table("herg.txt", sep='\t', header=T, row.names=NULL)
dt = na.omit(dt)
print(dim(dt))
dt.y = dt[,1:5]
dt.x = dt[,6:ncol(dt)]
dt.x.sd_of_descriptors = apply(dt.x, 2, sd)
dt.x = dt.x[,-which(dt.x.sd_of_descriptors == 0)]
dt.x = dt.x[-which(dt.y$IC50 > 500),]
dt.y = dt.y[-which(dt.y$IC50 > 500),]
print(dim(dt.x))
hist(dt.y$IC50)
hist(scale(log(dt.y$IC50)))
library(FactoMineR)
dt.x.pca = PCA(dt.x, ncp=5, axes=c(1,2), graph=T)
cor(dt.y$IC50, dt.x[,1])
cor(dt.y$IC50, dt.x[,10])
cor(dt.y$IC50, dt.x[,92])
#Best correlation for activity vs D10
lsfitD10 = lsfit(dt.y$IC50, dt.x[,10])
plot(dt.y$IC50, dt.x[,10])
abline(lsfitD10, col="red")
library(corrplot)
dt.x.cor = cor(dt.x[,1:10])
corrplot(dt.x.cor)
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
dt.x = dt.x[,elimcor_sansY(dt.x, s=0.8)$possetap]
dim(dt.x)
index = sample(nrow(dt.y), round(2/3*nrow(dt.y)), replace=F)
dt.x.lrn = dt.x[index,]
dt.x.tst = dt.x[-index,]
dt.y.lrn = dt.y[index,]
dt.y.tst = dt.y[-index,]
lm.lrn = lm(dt.y.lrn$IC50 ~ ., data = dt.x.lrn)
lm.lrn
#step.lrn <- step(lm.lrn)
length(step.lrn)
step.lrn <- step(lm.lrn)
#step.lrn <- step(lm.lrn)
length(step.lrn)
#Le step a gardé 13 variables
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
mean(dt.y.tst$IC50 - pred.lm)
sd(dt.y.tst$IC50 - pred.lm)
mean(dt.y.tst$IC50 - pred.step)
sd(dt.y.tst$IC50 - pred.step)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
plsr(dt.x.lrn)
plsr(dt.x.lrn, dt.y.lrn, ncomp=6)
pls(dt.x.lrn, dt.y.lrn, ncomp=6)
library(plsr)
library(pls)
library(PLS)
library(pls)
library(pls)
library(pls)
library(pls)
pls(dt.x.lrn, dt.y.lrn, ncomp=6)
install.packages("pls")
library(pls)
pls(dt.x.lrn, dt.y.lrn, ncomp=6)
plsr(dt.x.lrn, dt.y.lrn, ncomp=6)
pls(dt.x.lrn, dt.y.lrn, ncomp=6)
plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=6)
summary(pls.lrn)
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=6)
summary(pls.lrn)
rmsep(pls.lrn)
RMSEP(pls.lrn)
plot(RMSEP(pls.lrn))
RMSEP(pls.lrn)
plot(RMSEP(pls.lrn))
plot(RMSEP(pls.lrn, newdata=dt.y.tst$IC50))
RMSEP(pls.lrn, newdata=dt.y.tst$IC50)
RMSEP(pls.lrn, newdata=dt.y.tst)
RMSEP(pls.lrn, newdata=dt.x.tst)
RMSEP(pls.lrn, newdata=dt.y.tst)
RMSEP(pls.lrn, newdata=dt.y.tst$IC50)
RMSEP(pls.lrn, newdata=dt.y.lrn)
plot(RMSEP(pls.lrn))
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=15)
summary(pls.lrn)
plot(RMSEP(pls.lrn))
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=40)
summary(pls.lrn)
plot(RMSEP(pls.lrn))
plot(RMSEP(pls.lrn))
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=80)
plot(RMSEP(pls.lrn))
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=90)
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=85)
plot(RMSEP(pls.lrn))
pred.step = predict(step.lrn, dt.x.tst)
plot(dt.y.tst$IC50, pred.step)
abline(step.lrn)
plot(dt.y.tst$IC50, pred.step)
abline(step.lrn)
lsfit(step.lrn)
plot(dt.y.tst$IC50, pred.step)
abline(lsfit(dt.y.tst$IC50, pred.step))
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
plot(dt.y.tst$pIC50, pred.step)
abline(lsfit(dt.y.tst$pIC50, pred.step), col="red")
plot(dt.y.tst$pIC50, pred.step)
abline(lsfit(dt.y.tst$pIC50, pred.step), col="blue")
# mean(dt.y.tst$IC50 - pred.lm)
# sd(dt.y.tst$IC50 - pred.lm)
# mean(dt.y.tst$IC50 - pred.step)
# sd(dt.y.tst$IC50 - pred.step)
#
# hist(dt.y.tst$IC50 - pred.lm)
# hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
plot(dt.y.tst$pIC50, pred.lm)
abline(lsfit(dt.y.tst$pIC50, pred.lm), col="red")
plot(dt.y.tst$pIC50, pred.step)
abline(lsfit(dt.y.tst$pIC50, pred.step), col="blue")
# mean(dt.y.tst$IC50 - pred.lm)
# sd(dt.y.tst$IC50 - pred.lm)
# mean(dt.y.tst$IC50 - pred.step)
# sd(dt.y.tst$IC50 - pred.step)
#
# hist(dt.y.tst$IC50 - pred.lm)
# hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
plot(dt.y.tst$pIC50, pred.lm)
abline(lsfit(dt.y.tst$pIC50, pred.lm), col="red")
plot(dt.y.tst$pIC50, pred.step)
abline(lsfit(dt.y.tst$pIC50, pred.step), col="blue")
# mean(dt.y.tst$IC50 - pred.lm)
# sd(dt.y.tst$IC50 - pred.lm)
# mean(dt.y.tst$IC50 - pred.step)
# sd(dt.y.tst$IC50 - pred.step)
#
# hist(dt.y.tst$IC50 - pred.lm)
# hist(dt.y.tst$IC50 - pred.step)
library(pls)
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = step.lrn, ncomp=6)
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=6)
summary(pls.lrn)
plot(RMSEP(pls.lrn))
names(dt.y)
pls.lrn.loo = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=6, validation="LOO")
plot(RMSEP(pls.lrn.loo))
pls.lrn.loo = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=15, validation="LOO")
plot(RMSEP(pls.lrn.loo))
pls.lrn.loo = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=40, validation="LOO")
plot(RMSEP(pls.lrn.loo))
pls.lrn.loo = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=6, validation="LOO")
plot(RMSEP(pls.lrn.loo))
RMSEP(pls.lrn, newdata=dt.y.tst)
pls.lrn.loo = plsr(dt.y.lrn$pIC50 ~ ., data = dt.x.lrn, ncomp=6, validation="LOO")
plot(RMSEP(pls.lrn.loo))
pls.lrn.loo = plsr(dt.y.lrn$pIC50 ~ ., data = dt.x.lrn, ncomp=15, validation="LOO")
plot(RMSEP(pls.lrn.loo))
names(dt.y.lrn)
names(dt.y.tst)
RMSEP(pls.lrn, newdata=cbind(dt.y.tst, dt.x.tst))
predict(pls.lrn, dt.x.tst)
pred.pls = predict(pls.lrn, dt.x.tst)
RMSEP(pred.pls)
pred.pls = predict(pls.lrn, dt.x.tst)
pred.pls = predict(pls.lrn, dt.x.tst)
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=4)
predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst))
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=4)
pred.pls = predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst))
plot()
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=4)
pred.pls = predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst))
plot(pred.pls)
predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst))
plot(pred.pls, dt.y.tst$IC50)
predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst))
class(pred.pls)
dim(pred.pls)
dim(dt.y.tst)
plot(pred.pls[1,,], dt.y.tst$IC50)
length(dt.y.tst$IC50)
length(pred.pls[1,,])
length(pred.pls[,,1])
plot(pred.pls[,,1], dt.y.tst$IC50)
plot(dt.y.tst$IC50)
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=4)
pred.pls = predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst))
plot(dt.y.tst$IC50, pred.pls)
pls.lrn = plsr(dt.y.lrn$IC50 ~ ., data = dt.x.lrn, ncomp=4)
pred.pls = predict(pls.lrn, dt.x.tst)
plot(dt.y.tst$IC50, pred.pls)
class(pred.lm)
class(pred.step)
class(pred.pls)
pred.pls = predict(pls.lrn, dt.x.tst)
class(pred.pls)
dim(pred.pls)
names(pred.plz)
names(pred.pls)
pred.pls
pred.pls = predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst), ncomp=4)
pred.pls
pred.pls = predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst), ncomp=4)
pred.pls = predict(pls.lrn, dt.x.tst, ncomp=4)
plot(dt.y.tst$IC50, pred.pls)
abline(lsfit(dt.y.tst$pIC50, pred.pls), col="green")
pred.pls = predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst), ncomp=4)
pred.pls = predict(pls.lrn, dt.x.tst, ncomp=4)
plot(dt.y.tst$IC50, pred.pls[,,1])
abline(lsfit(dt.y.tst$pIC50, pred.pls), col="green")
pred.pls = predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst), ncomp=4)
pred.pls = predict(pls.lrn, dt.x.tst, ncomp=4)
plot(dt.y.tst$IC50, pred.pls)
abline(lsfit(dt.y.tst$pIC50, pred.pls), col="green")
pred.pls = predict(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst), ncomp=4)
pred.pls = predict(pls.lrn, dt.x.tst, ncomp=4)
plot(dt.y.tst$IC50, pred.pls)
abline(lsfit(dt.y.tst$IC50, pred.pls), col="green")
pred.pls = predict(pls.lrn, dt.x.tst, ncomp=4)
plot(dt.y.tst$IC50, pred.pls)
abline(lsfit(dt.y.tst$IC50, pred.pls), col="green")
dim(pred.pls)
library(pls)
pls.lrn = plsr(dt.y.lrn$pIC50 ~ ., data = dt.x.lrn, ncomp=6)
summary(pls.lrn)
plot(RMSEP(pls.lrn))
pls.lrn.loo = plsr(dt.y.lrn$pIC50 ~ ., data = dt.x.lrn, ncomp=15, validation="LOO")
plot(RMSEP(pls.lrn.loo))
pred.pls = predict(pls.lrn, dt.x.tst, ncomp=4)
plot(dt.y.tst$pIC50, pred.pls)
abline(lsfit(dt.y.tst$pIC50, pred.pls), col="green")
plot(RMSEP(pred.pls))
R2(pls.lrn)
plot(RMSEP(pred.pls, newdata=dt.x.tst))
plot(RMSEP(pls.lrn, newdata=dt.x.tst))
plot(RMSEP(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst)))
RMSEP(pls.lrn, newdata=data.frame(dt.y.tst, dt.x.tst))
RMSEP(pls.lrn, newdata=pred.plz)
RMSEP(pls.lrn, newdata=pred.pls)
R2(pls.lrn)
