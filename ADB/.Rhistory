for (i in 1:26) {
pockets.glm = glm(pockets[,27] ~ pockets[,i], family="binomial")
pockets.glm.pvalues = c(pockets.glm.pvalues, summary(pockets.glm)$coefficients[2, 4])
}
pockets.glm.pvalues
pockets = pockets[,c(which(pockets.glm.pvalues < 0.3), 27)]
dim(pockets)
#Il ne reste que 21 variables
#Splitting into Learning sample and Test sample
index = sample(nrow(pockets), round(2/3*nrow(pockets)), replace=F)
pockets.lrn = pockets[index,]
pockets.tst = pockets[-index,]
#Fabrication du modèle GLM global, sur echantillon apprentissage
glm.lrn = glm(pockets.lrn[,21] ~ ., pockets.lrn[,-21], family="binomial")
pred.glm.tst = predict(glm.lrn, pockets.tst[,-21], type="response")
#prédictions avec glm
plot(pred.glm, col = "red")
pred.glm.lrn=predict(glm.lrn, pockets.lrn[,-21], type="response")
plot(pred.glm.lrn, col="red")
points(pockets.lrn[,21], col="blue")
pred.glm.lrn=predict(glm.lrn, pockets.lrn[,-21], type="response")
plot(pred.glm.lrn, col="red")
points(pockets.lrn[,21], col="blue")
prediction(pred.glm.lrn, pockets.lrn[,21])
library(ROCR)
library(ROCR)
prediction(pred.glm.lrn, pockets.lrn[,21])
# Courbe ROC
library(ROCR)
prediction = prediction(pred.glm.lrn, pockets.lrn[,21])
performance = performance(prediction, 'tpr', 'fpr')
# Courbe ROC
library(ROCR)
prediction = prediction(pred.glm.lrn, pockets.lrn[,21])
performance = performance(prediction, 'tpr', 'fpr')
plot(performance)
# Courbe ROC
library(ROCR)
prediction = prediction(pred.glm.lrn, pockets.lrn[,21])
performance = performance(prediction, 'tpr', 'fpr')
plot(performance)
auc = performance(prediction, 'auc')
attr(auc, 'y.values')
$
install.packages("MASS")
library(MASS)
pockets = read.table("descriptor_pocket.mat")
names(pockets)
dim(pockets)
#is.na(pockets)
pockets = na.omit(pockets)
dim(pockets)
aromatic = apply(cbind(pockets$F, pockets$Y, pockets$H, pockets$W), 1, sum)
polar = apply(cbind(pockets$C, pockets$D, pockets$E, pockets$H, pockets$K, pockets$N, pockets$Q, pockets$R, pockets$S, pockets$T, pockets$W, pockets$Y), 1, sum)
aliphatic = apply(cbind(pockets$I, pockets$L, pockets$V), 1, sum)
charged = apply(cbind(pockets$D, pockets$E, pockets$R, pockets$K, pockets$H), 1, sum)
negative = apply(cbind(pockets$D, pockets$E), 1, sum)
positive = apply(cbind(pockets$R, pockets$K, pockets$H), 1, sum)
hydrophobic = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$L, pockets$I, pockets$M, pockets$F, pockets$W, pockets$H, pockets$Y, pockets$K), 1, sum)
small = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$S, pockets$D, pockets$N, pockets$P), 1, sum)
tiny = apply(cbind(pockets$A, pockets$C, pockets$G, pockets$S), 1, sum)
pockets = cbind(pockets, aromatic, polar, aliphatic, charged, negative, positive, hydrophobic, small, tiny)
#mise de "drugg" à la fin du tableau
noms = names(pockets)
pockets = cbind(pockets[,1:27], pockets[,29:37], pockets[,28])
colnames(pockets)[37] = noms[28]
names(pockets)   #37 descriptors
boxplot(scale(pockets[,-37]), las=2)
#ma version
hist(pockets$polar[pockets$drugg == 1], freq=F, col = "purple", xlim = c(0, 1))
hist(pockets$polar[pockets$drugg == 0], freq=F, col =rgb(1,0,0,0.5), add=T)
#version prof
# par(mfrow = c(1, 2))
# for (i in c(1:36))
#     by(pockets[,i], pockets$drugg, hist, main = "un histogramme")
#ma version
# for (i in 1:36){
#     print(mean(pockets[,i][pockets$drugg == 1]))
#     print(mean(pockets[,i][pockets$drugg == 0]))
#     print(sd(pockets[,i][pockets$drugg == 1]))
#     print(sd(pockets[,i][pockets$drugg == 0]))
# }
#version prof
# lapply(pockets, mean)
# lapply(pockets, sd)
print(means <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = mean))
print(sds <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = sd))
pockets.pvalues = c()
for (i in 1:36){
# Optionnel, il faudrait comparer les variances, comme condition d'application du Student
#    var.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])
pvalue = t.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])$p.value
pockets.pvalues = c(pockets.pvalues, pvalue)
}
pockets.pvalues
drug.corr = cor(pockets[,-37])
library(corrplot)
corrplot(drug.corr)
# plot(pockets$polar, pockets$hydrophobic)
# plot(pockets$Real_volume, pockets$C_ATOM)
pockets.dist = dist(scale(pockets[,-37]))
# donne un matrice triangulaire inférieure de la distance de tous les résidus 2 à 2
pockets.tree = hclust(pockets.dist, method = "ward.D2")
plot(pockets.tree, hang=-1, labels = pockets$drugg, xlab = "Poches (1 = druggable, 0 = non-druggable)", ylab = "Distance", main = "Dendrogramme par la m?thode de Ward")
rect.hclust(pockets.tree, k = 5, border = "red")
# rect.hclust(pockets.tree, k = 6, border = "red")
# rect.hclust(pockets.tree, k = 8, border = "red")
pockets.kmeans = kmeans(pockets[, -37], centers = 3)
pockets.kmeans$cluster
plot(hclust(pockets.dist), hang = -1, labels = as.factor(pockets.kmeans$cluster))
I.intra = rep(0, 10)
I.intra
for (i in 1:length(I.intra)){
I.intra[i] = kmeans(pockets, centers = i)$tot.withinss
}
plot(I.intra, type = "l", xlab = "Nombre de clusters", ylab = "Inertie intra-classe", main = "D?termination du nombre de cluster id?al par la m?thode des kmeans")
abline(v=3, col = "red")
text(3, 40000000, "3 clusters", col = "red")
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp12$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp12$eig))
barplot(pockets.acp12$eig[,3], main="Somme cumulé des variances")
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(pockets.acp12, choix = "ind", col.ind = pockets.kmeans$cluster)
library(MASS)
#Elimination des variables corrélées
elimcor_sansY<-function(X,s=0.95){
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
pockets = pockets[,c(elimcor_sansY(pockets[,-37], 0.6)$possetap, 37)]
dim(pockets)
#création du modèle GLM variable par variable
#récupération des p-values
pockets.glm.pvalues = c()
for (i in 1:26) {
pockets.glm = glm(pockets[,27] ~ pockets[,i], family="binomial")
pockets.glm.pvalues = c(pockets.glm.pvalues, summary(pockets.glm)$coefficients[2, 4])
}
pockets.glm.pvalues
pockets = pockets[,c(which(pockets.glm.pvalues < 0.3), 27)]
dim(pockets)
#Il ne reste que 21 variables
#Splitting into Learning sample and Test sample
index = sample(nrow(pockets), round(2/3*nrow(pockets)), replace=F)
pockets.lrn = pockets[index,]
pockets.tst = pockets[-index,]
#Fabrication du modèle GLM global, sur echantillon apprentissage
glm.lrn = glm(pockets.lrn[,21] ~ ., pockets.lrn[,-21], family="binomial")
pred.glm.tst = predict(glm.lrn, pockets.tst[,-21], type="response")
#prédictions avec glm
plot(pred.glm, col = "red")
pockets.lda = lda(drugg ~ ., data=pockets)
pockets.lda = lda(drugg ~ ., data=pockets)
pockets.lda$prior
pockets.lda
pockets[10,]
pockets[1:10,]
dim(pockets)
pockets = read.table("descriptor_pocket.mat")
names(pockets)
dim(pockets)
#is.na(pockets)
pockets = na.omit(pockets)
dim(pockets)
aromatic = apply(cbind(pockets$F, pockets$Y, pockets$H, pockets$W), 1, sum)
polar = apply(cbind(pockets$C, pockets$D, pockets$E, pockets$H, pockets$K, pockets$N, pockets$Q, pockets$R, pockets$S, pockets$T, pockets$W, pockets$Y), 1, sum)
aliphatic = apply(cbind(pockets$I, pockets$L, pockets$V), 1, sum)
charged = apply(cbind(pockets$D, pockets$E, pockets$R, pockets$K, pockets$H), 1, sum)
negative = apply(cbind(pockets$D, pockets$E), 1, sum)
positive = apply(cbind(pockets$R, pockets$K, pockets$H), 1, sum)
hydrophobic = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$L, pockets$I, pockets$M, pockets$F, pockets$W, pockets$H, pockets$Y, pockets$K), 1, sum)
small = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$S, pockets$D, pockets$N, pockets$P), 1, sum)
tiny = apply(cbind(pockets$A, pockets$C, pockets$G, pockets$S), 1, sum)
pockets = cbind(pockets, aromatic, polar, aliphatic, charged, negative, positive, hydrophobic, small, tiny)
#mise de "drugg" à la fin du tableau
noms = names(pockets)
pockets = cbind(pockets[,1:27], pockets[,29:37], pockets[,28])
colnames(pockets)[37] = noms[28]
names(pockets)   #37 descriptors
boxplot(scale(pockets[,-37]), las=2)
#ma version
hist(pockets$polar[pockets$drugg == 1], freq=F, col = "purple", xlim = c(0, 1))
hist(pockets$polar[pockets$drugg == 0], freq=F, col =rgb(1,0,0,0.5), add=T)
#version prof
# par(mfrow = c(1, 2))
# for (i in c(1:36))
#     by(pockets[,i], pockets$drugg, hist, main = "un histogramme")
#ma version
# for (i in 1:36){
#     print(mean(pockets[,i][pockets$drugg == 1]))
#     print(mean(pockets[,i][pockets$drugg == 0]))
#     print(sd(pockets[,i][pockets$drugg == 1]))
#     print(sd(pockets[,i][pockets$drugg == 0]))
# }
#version prof
# lapply(pockets, mean)
# lapply(pockets, sd)
print(means <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = mean))
print(sds <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = sd))
pockets.pvalues = c()
for (i in 1:36){
# Optionnel, il faudrait comparer les variances, comme condition d'application du Student
#    var.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])
pvalue = t.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])$p.value
pockets.pvalues = c(pockets.pvalues, pvalue)
}
pockets.pvalues
drug.corr = cor(pockets[,-37])
library(corrplot)
corrplot(drug.corr)
# plot(pockets$polar, pockets$hydrophobic)
# plot(pockets$Real_volume, pockets$C_ATOM)
pockets.dist = dist(scale(pockets[,-37]))
# donne un matrice triangulaire inférieure de la distance de tous les résidus 2 à 2
pockets.tree = hclust(pockets.dist, method = "ward.D2")
plot(pockets.tree, hang=-1, labels = pockets$drugg, xlab = "Poches (1 = druggable, 0 = non-druggable)", ylab = "Distance", main = "Dendrogramme par la m?thode de Ward")
rect.hclust(pockets.tree, k = 5, border = "red")
# rect.hclust(pockets.tree, k = 6, border = "red")
# rect.hclust(pockets.tree, k = 8, border = "red")
pockets.kmeans = kmeans(pockets[, -37], centers = 3)
pockets.kmeans$cluster
plot(hclust(pockets.dist), hang = -1, labels = as.factor(pockets.kmeans$cluster))
I.intra = rep(0, 10)
I.intra
for (i in 1:length(I.intra)){
I.intra[i] = kmeans(pockets, centers = i)$tot.withinss
}
plot(I.intra, type = "l", xlab = "Nombre de clusters", ylab = "Inertie intra-classe", main = "D?termination du nombre de cluster id?al par la m?thode des kmeans")
abline(v=3, col = "red")
text(3, 40000000, "3 clusters", col = "red")
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp12$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp12$eig))
barplot(pockets.acp12$eig[,3], main="Somme cumulé des variances")
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(pockets.acp12, choix = "ind", col.ind = pockets.kmeans$cluster)
library(MASS)
pockets.lda = lda(drugg ~ ., data=pockets)
pockets.lda
dim(pockets)
pockets.lda$svd
pockets.lda
library(MASS)
pockets.lda = lda(drugg ~ ., data=pockets.lrn)
pockets.lda
dim(pockets.lrn)
#Splitting into Learning sample and Test sample
index = sample(nrow(pockets), round(2/3*nrow(pockets)), replace=F)
pockets.lrn = pockets[index,]
pockets.tst = pockets[-index,]
pockets = read.table("descriptor_pocket.mat")
names(pockets)
dim(pockets)
#is.na(pockets)
pockets = na.omit(pockets)
dim(pockets)
aromatic = apply(cbind(pockets$F, pockets$Y, pockets$H, pockets$W), 1, sum)
polar = apply(cbind(pockets$C, pockets$D, pockets$E, pockets$H, pockets$K, pockets$N, pockets$Q, pockets$R, pockets$S, pockets$T, pockets$W, pockets$Y), 1, sum)
aliphatic = apply(cbind(pockets$I, pockets$L, pockets$V), 1, sum)
charged = apply(cbind(pockets$D, pockets$E, pockets$R, pockets$K, pockets$H), 1, sum)
negative = apply(cbind(pockets$D, pockets$E), 1, sum)
positive = apply(cbind(pockets$R, pockets$K, pockets$H), 1, sum)
hydrophobic = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$L, pockets$I, pockets$M, pockets$F, pockets$W, pockets$H, pockets$Y, pockets$K), 1, sum)
small = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$S, pockets$D, pockets$N, pockets$P), 1, sum)
tiny = apply(cbind(pockets$A, pockets$C, pockets$G, pockets$S), 1, sum)
pockets = cbind(pockets, aromatic, polar, aliphatic, charged, negative, positive, hydrophobic, small, tiny)
#mise de "drugg" à la fin du tableau
noms = names(pockets)
pockets = cbind(pockets[,1:27], pockets[,29:37], pockets[,28])
colnames(pockets)[37] = noms[28]
names(pockets)   #37 descriptors
boxplot(scale(pockets[,-37]), las=2)
#ma version
hist(pockets$polar[pockets$drugg == 1], freq=F, col = "purple", xlim = c(0, 1))
hist(pockets$polar[pockets$drugg == 0], freq=F, col =rgb(1,0,0,0.5), add=T)
#version prof
# par(mfrow = c(1, 2))
# for (i in c(1:36))
#     by(pockets[,i], pockets$drugg, hist, main = "un histogramme")
#ma version
# for (i in 1:36){
#     print(mean(pockets[,i][pockets$drugg == 1]))
#     print(mean(pockets[,i][pockets$drugg == 0]))
#     print(sd(pockets[,i][pockets$drugg == 1]))
#     print(sd(pockets[,i][pockets$drugg == 0]))
# }
#version prof
# lapply(pockets, mean)
# lapply(pockets, sd)
print(means <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = mean))
print(sds <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = sd))
pockets.pvalues = c()
for (i in 1:36){
# Optionnel, il faudrait comparer les variances, comme condition d'application du Student
#    var.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])
pvalue = t.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])$p.value
pockets.pvalues = c(pockets.pvalues, pvalue)
}
pockets.pvalues
drug.corr = cor(pockets[,-37])
library(corrplot)
corrplot(drug.corr)
# plot(pockets$polar, pockets$hydrophobic)
# plot(pockets$Real_volume, pockets$C_ATOM)
pockets.dist = dist(scale(pockets[,-37]))
# donne un matrice triangulaire inférieure de la distance de tous les résidus 2 à 2
pockets.tree = hclust(pockets.dist, method = "ward.D2")
plot(pockets.tree, hang=-1, labels = pockets$drugg, xlab = "Poches (1 = druggable, 0 = non-druggable)", ylab = "Distance", main = "Dendrogramme par la m?thode de Ward")
rect.hclust(pockets.tree, k = 5, border = "red")
# rect.hclust(pockets.tree, k = 6, border = "red")
# rect.hclust(pockets.tree, k = 8, border = "red")
pockets.kmeans = kmeans(pockets[, -37], centers = 3)
pockets.kmeans$cluster
plot(hclust(pockets.dist), hang = -1, labels = as.factor(pockets.kmeans$cluster))
I.intra = rep(0, 10)
I.intra
for (i in 1:length(I.intra)){
I.intra[i] = kmeans(pockets, centers = i)$tot.withinss
}
plot(I.intra, type = "l", xlab = "Nombre de clusters", ylab = "Inertie intra-classe", main = "D?termination du nombre de cluster id?al par la m?thode des kmeans")
abline(v=3, col = "red")
text(3, 40000000, "3 clusters", col = "red")
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp12$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp12$eig))
barplot(pockets.acp12$eig[,3], main="Somme cumulé des variances")
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(pockets.acp12, choix = "ind", col.ind = pockets.kmeans$cluster)
#Splitting into Learning sample and Test sample
index = sample(nrow(pockets), round(2/3*nrow(pockets)), replace=F)
pockets.lrn = pockets[index,]
pockets.tst = pockets[-index,]
library(MASS)
pockets.lda = lda(drugg ~ ., data=pockets.lrn)
pockets.lda
plot(pockets.lda)
library(MASS)
pockets.lda = lda(drugg ~ ., data=pockets.lrn)
pockets.lda
plot(pockets.lda)
lda(pockets[,-37])
pockets.lda
library(MASS)
pockets.lda = lda(drugg ~ ., data=pockets.lrn)
pockets.lda
plot(pockets.lda)
library(MASS)
pockets.lda = lda(drugg ~ ., data=pockets.lrn)
pockets.lda
plot(pockets.lda)
pockets.lda$prior
pockets.lda$scaling
pockets.lda$means
pockets.lda$prior
pockets.lda$prior
pockets.lda$scaling
pockets.lda$means
table(pockets[,37])
table(pockets[,37], dnn=c("obs", "pred"))
pred.lda = predict(pockets.lda, pockets.tst[-37])
table(pockets[,37], pred.lda, dnn=c("obs", "pred"))
table(pockets.tst[,37], pred.lda, dnn=c("obs", "pred"))
dim(pred.lda)
pred.lda = predict(pockets.lda, pockets.tst[-37])
dim(pred.lda)
pred.lda = predict(pockets.lda, pockets.tst[,-37])
dim(pred.lda)
pred.lda = predict(pockets.lda, pockets.tst[,-37])
dim(pred.lda)
predict(pockets.lda, pockets.tst[,-37])
lda.lrn = lda(drugg ~ ., pockets.lrn[,-37], family="binomial")
lda.lrn = lda(drugg ~ ., data=pockets.lrn, family="binomial")
pred.lda = predict(lda.lrn, pockets.tst[,-37], type="response")
pred.lda
pred.lda$class
dim(pred.lda$class)
length(pred.lda$class)
table(pockets.tst[,37], pred.lda$class, dnn=c("obs", "pred"))
class(lda.table)
lda.table = table(pockets.tst[,37], pred.lda$class, dnn=c("obs", "pred"))
class(lda.table)
as.matrix(lda.table)
class(as.matrix(lda.table))
lda.table[1, 1]
lda.table[2, 1]
lda.table
tp = lda.table[2, 2]
tn = lda.table[1, 1]
fp = lda.table[1, 2]
fn = lda.table[2, 1]
lda.accu = (tp+tn) / (tp+fp+tn+fn)
lda.sens = tp / (tp+fn)
lda.accu = (tp+tn) / (tp+fp+tn+fn)
lda.sens = tp / (tp+fn)
lda.spec = tn / (tn+fp)
lda.sens
lda.accu
lda.sens
lda.spec
lda.lrn = lda(drugg ~ ., data=pockets.lrn, family="binomial")
pred.lda = predict(lda.lrn, pockets.tst[,-37], type="response")
length(pred.lda$class)
lda.table = table(pockets.tst[,37], pred.lda$class, dnn=c("obs", "pred"))
lda.table
tp = lda.table[2, 2]
tn = lda.table[1, 1]
fp = lda.table[1, 2]
fn = lda.table[2, 1]
lda.accu = (tp+tn) / (tp+fp+tn+fn)
lda.sens = tp / (tp+fn)
lda.spec = tn / (tn+fp)
lda.accu
lda.sens
lda.spec
lda.lrn = lda(drugg ~ ., data=pockets.lrn, family="binomial")
pred.lda = predict(lda.lrn, pockets.tst[,-37], type="response")
length(pred.lda$class)
lda.table = table(pockets.tst[,37], pred.lda$class, dnn=c("obs", "pred"))
lda.table
tp = lda.table[2, 2]
tn = lda.table[1, 1]
fp = lda.table[1, 2]
fn = lda.table[2, 1]
lda.accu = (tp+tn) / (tp+fp+tn+fn)
lda.sens = tp / (tp+fn)
lda.spec = tn / (tn+fp)
lda.accu
lda.sens
lda.spec
library(MASS)
lda.lrn = lda(drugg ~ ., data=pockets.lrn, family="binomial")
plot(lda.lrn)
library(MASS)
lda.lrn = lda(drugg ~ ., data=pockets.lrn, family="binomial")
plot(lda.lrn)
library(MASS)
lda.lrn = lda(drugg ~ ., data=pockets.lrn)
plot(lda.lrn)
pred.lda = predict(lda.lrn, pockets.tst[,-37], type="response")
length(pred.lda$class)
lda.table = table(pockets.tst[,37], pred.lda$class, dnn=c("obs", "pred"))
lda.table
tp = lda.table[2, 2]
tn = lda.table[1, 1]
fp = lda.table[1, 2]
fn = lda.table[2, 1]
lda.accu = (tp+tn) / (tp+fp+tn+fn)
lda.sens = tp / (tp+fn)
lda.spec = tn / (tn+fp)
lda.accu
lda.sens
lda.spec
