gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
print(elimcor_sansY(dt.x, s=0.8))
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
print(elimcor_sansY(dt.x, s=0.8)$groupes)
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
print(elimcor_sansY(dt.x, s=0.8)$possetap)
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
dt.x.elimcor = dt.x[,elimcor_sansY(dt.x, s=0.8)$possetap]
dim(dt.x.elimcor)
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
dt.x = dt.x[,elimcor_sansY(dt.x, s=0.8)$possetap]
dim(dt.x.elimcor)
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
dt.x = dt.x[,elimcor_sansY(dt.x, s=0.8)$possetap]
dim(dt.x)
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
dt.x = dt.x[,elimcor_sansY(dt.x, s=0.8)$possetap]
dim(dt.x)
knitr::opts_chunk$set(echo = TRUE)
dt = read.table("herg.txt", sep='\t', header=T, row.names=NULL)
dt = na.omit(dt)
print(dim(dt))
dt.y = dt[,1:5]
dt.x = dt[,6:ncol(dt)]
dt.x.sd_of_descriptors = apply(dt.x, 2, sd)
dt.x = dt.x[,-which(dt.sd_of_descriptors == 0)]
dt.x = dt.x[-which(dt.y$IC50 > 500),]
dt.y = dt.y[-which(dt.y$IC50 > 500),]
print(dim(dt.x))
hist(dt.y$IC50)
hist(scale(log(dt.y$IC50)))
library(FactoMineR)
dt.x.pca = PCA(dt.x, ncp=5, axes=c(1,2), graph=T)
cor(dt.y$IC50, dt.x[,1])
cor(dt.y$IC50, dt.x[,10])
cor(dt.y$IC50, dt.x[,92])
#Best correlation for activity vs D10
lsfitD10 = lsfit(dt.y$IC50, dt.x[,10])
plot(dt.y$IC50, dt.x[,10])
abline(lsfitD10, col="red")
library(corrplot)
dt.x.cor = cor(dt.x[,1:10])
corrplot(dt.x.cor)
elimcor_sansY<-function(X,s=0.95) {
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
elimcor_sansY(dt.x, s=0.8)$possetap
dt.x = dt.x[,elimcor_sansY(dt.x, s=0.8)$possetap]
dim(dt.x)
splitting_lrn_tst <- function(data) {
#return lrn, tst
index = sample(nrow(dt.x), round(2/3*nrow(dt.x)), replace=F)
return(c(data[index,], data[-index,]))
}
dt.x.lrn, dt.x.tst = splitting_lrn_tst(dt.x)
splitting_lrn_tst <- function(data) {
#return lrn, tst
index = sample(nrow(dt.x), round(2/3*nrow(dt.x)), replace=F)
return(c(data[index,], data[-index,]))
}
dt.x.lrn = splitting_lrn_tst(dt.x)[1]
dt.x.tst = splitting_lrn_tst(dt.x)[2]
dt.y.lrn = splitting_lrn_tst(dt.x)[1]
dt.y.tst = splitting_lrn_tst(dt.x)[2]
index = sample(nrow(dt.y), round(2/3*nrow(dt.y)), replace=F)
dt.x.lrn = dt.x[index,]
dt.x.tst = dt.x[-index,]
dt.y.lrn = dt.y[index,]
dt.y.tst = dt.y[-index,]
lm(dt.y.lrn$IC50 ~ dt.x.lrn)
lm(dt.y.lrn$IC50 ~ list(dt.x.lrn))
lm(dt.y.lrn$IC50 ~ dt.x.lrn)
lm(dt.y.lrn$IC50 ~ ., data = dt.x.lrn)
lm.lrn = lm(dt.y.lrn$IC50 ~ ., data = dt.x.lrn)
summary(lm.lrn)
lm.lrn = lm(dt.y.lrn$IC50 ~ ., data = dt.x.lrn)
lm.lrn
lm.lrn = lm(dt.y.lrn$IC50 ~ dt.x.lrn)
lm.lrn = lm(dt.y.lrn$IC50 ~ ., data = dt.x.lrn)
lm.lrn
step(lm)
step(lm.lrn)
step(lm.lrn)$coefficients
summary(step(lm.lrn))
step.lrn = step(lm.lrn)
step.lrn <- step(lm.lrn)
step.lrn <- step(lm.lrn)
summary(step.lrn)
step.lrn
dim(step.lrn)
length(step.lrn)
predict(lm.lrn)
predict(lm.lrn)
predict(step.lrn)
predict(lm.lrn)
predict(step.lrn)
predict(step.lrn, dt.x.tst)
predict(lm.lrn, dt.x.tst)
predict(step.lrn, dt.x.tst)
hist(dt.y.tst$IC50 - pred.lm)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
mean(dt.y.tst$IC50 - pred.lm)
sd(dt.y.tst$IC50 - pred.lm)
mean(dt.y.tst$IC50 - pred.step)
sd(dt.y.tst$IC50 - pred.step)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
pred.lm = predict(lm.lrn, dt.x.tst)
pred.step = predict(step.lrn, dt.x.tst)
mean(dt.y.tst$IC50 - pred.lm)
sd(dt.y.tst$IC50 - pred.lm)
mean(dt.y.tst$IC50 - pred.step)
sd(dt.y.tst$IC50 - pred.step)
hist(dt.y.tst$IC50 - pred.lm)
hist(dt.y.tst$IC50 - pred.step)
