# lapply(pockets, mean)
# lapply(pockets, sd)
print(means <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = mean))
print(sds <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = sd))
pockets.pvalues = c()
for (i in 1:36){
# Optionnel, il faudrait comparer les variances, comme condition d'application du Student
#    var.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])
pvalue = t.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])$p.value
pockets.pvalues = c(pockets.pvalues, pvalue)
}
pockets.pvalues
drug.corr = cor(pockets[,-37])
library(corrplot)
corrplot(drug.corr)
# plot(pockets$polar, pockets$hydrophobic)
# plot(pockets$Real_volume, pockets$C_ATOM)
pockets.dist = dist(scale(pockets[,-37]))
# donne un matrice triangulaire inférieure de la distance de tous les résidus 2 à 2
pockets.tree = hclust(pockets.dist, method = "ward.D2")
plot(pockets.tree, hang=-1, labels = pockets$drugg, xlab = "Poches (1 = druggable, 0 = non-druggable)", ylab = "Distance", main = "Dendrogramme par la m?thode de Ward")
rect.hclust(pockets.tree, k = 5, border = "red")
# rect.hclust(pockets.tree, k = 6, border = "red")
# rect.hclust(pockets.tree, k = 8, border = "red")
pockets.kmeans = kmeans(pockets[, -37], centers = 3)
pockets.kmeans$cluster
plot(hclust(pockets.dist), hang = -1, labels = as.factor(pockets.kmeans$cluster))
I.intra = rep(0, 10)
I.intra
for (i in 1:length(I.intra)){
I.intra[i] = kmeans(pockets, centers = i)$tot.withinss
}
plot(I.intra, type = "l", xlab = "Nombre de clusters", ylab = "Inertie intra-classe", main = "D?termination du nombre de cluster id?al par la m?thode des kmeans")
abline(v=3, col = "red")
text(3, 40000000, "3 clusters", col = "red")
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp12$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp12$eig))
barplot(pockets.acp12$eig[,3], main="Somme cumulé des variances")
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(pockets.acp12, choix = "ind", col.ind = pockets.kmeans$cluster)
#Elimination des variables corrélées
elimcor_sansY<-function(X,s=0.95){
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
pockets = pockets[,c(elimcor_sansY(pockets[,-37], 0.7)$possetap, 37)]
dim(pockets)
pockets
plot(cars)
pockets = read.table("descriptor_pocket.mat")
names(pockets)
dim(pockets)
#is.na(pockets)
pockets = na.omit(pockets)
dim(pockets)
aromatic = apply(cbind(pockets$F, pockets$Y, pockets$H, pockets$W), 1, sum)
polar = apply(cbind(pockets$C, pockets$D, pockets$E, pockets$H, pockets$K, pockets$N, pockets$Q, pockets$R, pockets$S, pockets$T, pockets$W, pockets$Y), 1, sum)
aliphatic = apply(cbind(pockets$I, pockets$L, pockets$V), 1, sum)
charged = apply(cbind(pockets$D, pockets$E, pockets$R, pockets$K, pockets$H), 1, sum)
negative = apply(cbind(pockets$D, pockets$E), 1, sum)
positive = apply(cbind(pockets$R, pockets$K, pockets$H), 1, sum)
hydrophobic = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$L, pockets$I, pockets$M, pockets$F, pockets$W, pockets$H, pockets$Y, pockets$K), 1, sum)
small = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$S, pockets$D, pockets$N, pockets$P), 1, sum)
tiny = apply(cbind(pockets$A, pockets$C, pockets$G, pockets$S), 1, sum)
pockets = cbind(pockets, aromatic, polar, aliphatic, charged, negative, positive, hydrophobic, small, tiny)
#mise de "drugg" à la fin du tableau
noms = names(pockets)
pockets = cbind(pockets[,1:27], pockets[,29:37], pockets[,28])
colnames(pockets)[37] = noms[28]
names(pockets)   #37 descriptors
boxplot(scale(pockets[,-37]), las=2)
#ma version
hist(pockets$polar[pockets$drugg == 1], freq=F, col = "purple", xlim = c(0, 1))
hist(pockets$polar[pockets$drugg == 0], freq=F, col =rgb(1,0,0,0.5), add=T)
#version prof
# par(mfrow = c(1, 2))
# for (i in c(1:36))
#     by(pockets[,i], pockets$drugg, hist, main = "un histogramme")
#ma version
# for (i in 1:36){
#     print(mean(pockets[,i][pockets$drugg == 1]))
#     print(mean(pockets[,i][pockets$drugg == 0]))
#     print(sd(pockets[,i][pockets$drugg == 1]))
#     print(sd(pockets[,i][pockets$drugg == 0]))
# }
#version prof
# lapply(pockets, mean)
# lapply(pockets, sd)
print(means <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = mean))
print(sds <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = sd))
pockets.pvalues = c()
for (i in 1:36){
# Optionnel, il faudrait comparer les variances, comme condition d'application du Student
#    var.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])
pvalue = t.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])$p.value
pockets.pvalues = c(pockets.pvalues, pvalue)
}
pockets.pvalues
drug.corr = cor(pockets[,-37])
library(corrplot)
corrplot(drug.corr)
# plot(pockets$polar, pockets$hydrophobic)
# plot(pockets$Real_volume, pockets$C_ATOM)
pockets.dist = dist(scale(pockets[,-37]))
# donne un matrice triangulaire inférieure de la distance de tous les résidus 2 à 2
pockets.tree = hclust(pockets.dist, method = "ward.D2")
plot(pockets.tree, hang=-1, labels = pockets$drugg, xlab = "Poches (1 = druggable, 0 = non-druggable)", ylab = "Distance", main = "Dendrogramme par la m?thode de Ward")
rect.hclust(pockets.tree, k = 5, border = "red")
# rect.hclust(pockets.tree, k = 6, border = "red")
# rect.hclust(pockets.tree, k = 8, border = "red")
pockets.kmeans = kmeans(pockets[, -37], centers = 3)
pockets.kmeans$cluster
plot(hclust(pockets.dist), hang = -1, labels = as.factor(pockets.kmeans$cluster))
I.intra = rep(0, 10)
I.intra
for (i in 1:length(I.intra)){
I.intra[i] = kmeans(pockets, centers = i)$tot.withinss
}
plot(I.intra, type = "l", xlab = "Nombre de clusters", ylab = "Inertie intra-classe", main = "D?termination du nombre de cluster id?al par la m?thode des kmeans")
abline(v=3, col = "red")
text(3, 40000000, "3 clusters", col = "red")
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp12$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp12$eig))
barplot(pockets.acp12$eig[,3], main="Somme cumulé des variances")
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(pockets.acp12, choix = "ind", col.ind = pockets.kmeans$cluster)
#Elimination des variables corrélées
elimcor_sansY<-function(X,s=0.95){
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
pockets = pockets[,c(elimcor_sansY(pockets[,-37], 0.9)$possetap, 37)]
pockets
plot(cars)
pockets = read.table("descriptor_pocket.mat")
names(pockets)
dim(pockets)
#is.na(pockets)
pockets = na.omit(pockets)
dim(pockets)
aromatic = apply(cbind(pockets$F, pockets$Y, pockets$H, pockets$W), 1, sum)
polar = apply(cbind(pockets$C, pockets$D, pockets$E, pockets$H, pockets$K, pockets$N, pockets$Q, pockets$R, pockets$S, pockets$T, pockets$W, pockets$Y), 1, sum)
aliphatic = apply(cbind(pockets$I, pockets$L, pockets$V), 1, sum)
charged = apply(cbind(pockets$D, pockets$E, pockets$R, pockets$K, pockets$H), 1, sum)
negative = apply(cbind(pockets$D, pockets$E), 1, sum)
positive = apply(cbind(pockets$R, pockets$K, pockets$H), 1, sum)
hydrophobic = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$L, pockets$I, pockets$M, pockets$F, pockets$W, pockets$H, pockets$Y, pockets$K), 1, sum)
small = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$S, pockets$D, pockets$N, pockets$P), 1, sum)
tiny = apply(cbind(pockets$A, pockets$C, pockets$G, pockets$S), 1, sum)
pockets = cbind(pockets, aromatic, polar, aliphatic, charged, negative, positive, hydrophobic, small, tiny)
#mise de "drugg" à la fin du tableau
noms = names(pockets)
pockets = cbind(pockets[,1:27], pockets[,29:37], pockets[,28])
colnames(pockets)[37] = noms[28]
names(pockets)   #37 descriptors
boxplot(scale(pockets[,-37]), las=2)
#ma version
hist(pockets$polar[pockets$drugg == 1], freq=F, col = "purple", xlim = c(0, 1))
hist(pockets$polar[pockets$drugg == 0], freq=F, col =rgb(1,0,0,0.5), add=T)
#version prof
# par(mfrow = c(1, 2))
# for (i in c(1:36))
#     by(pockets[,i], pockets$drugg, hist, main = "un histogramme")
#ma version
# for (i in 1:36){
#     print(mean(pockets[,i][pockets$drugg == 1]))
#     print(mean(pockets[,i][pockets$drugg == 0]))
#     print(sd(pockets[,i][pockets$drugg == 1]))
#     print(sd(pockets[,i][pockets$drugg == 0]))
# }
#version prof
# lapply(pockets, mean)
# lapply(pockets, sd)
print(means <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = mean))
print(sds <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = sd))
pockets.pvalues = c()
for (i in 1:36){
# Optionnel, il faudrait comparer les variances, comme condition d'application du Student
#    var.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])
pvalue = t.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])$p.value
pockets.pvalues = c(pockets.pvalues, pvalue)
}
pockets.pvalues
drug.corr = cor(pockets[,-37])
library(corrplot)
corrplot(drug.corr)
# plot(pockets$polar, pockets$hydrophobic)
# plot(pockets$Real_volume, pockets$C_ATOM)
pockets.dist = dist(scale(pockets[,-37]))
# donne un matrice triangulaire inférieure de la distance de tous les résidus 2 à 2
pockets.tree = hclust(pockets.dist, method = "ward.D2")
plot(pockets.tree, hang=-1, labels = pockets$drugg, xlab = "Poches (1 = druggable, 0 = non-druggable)", ylab = "Distance", main = "Dendrogramme par la m?thode de Ward")
rect.hclust(pockets.tree, k = 5, border = "red")
# rect.hclust(pockets.tree, k = 6, border = "red")
# rect.hclust(pockets.tree, k = 8, border = "red")
pockets.kmeans = kmeans(pockets[, -37], centers = 3)
pockets.kmeans$cluster
plot(hclust(pockets.dist), hang = -1, labels = as.factor(pockets.kmeans$cluster))
I.intra = rep(0, 10)
I.intra
for (i in 1:length(I.intra)){
I.intra[i] = kmeans(pockets, centers = i)$tot.withinss
}
plot(I.intra, type = "l", xlab = "Nombre de clusters", ylab = "Inertie intra-classe", main = "D?termination du nombre de cluster id?al par la m?thode des kmeans")
abline(v=3, col = "red")
text(3, 40000000, "3 clusters", col = "red")
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp12$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp12$eig))
barplot(pockets.acp12$eig[,3], main="Somme cumulé des variances")
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(pockets.acp12, choix = "ind", col.ind = pockets.kmeans$cluster)
#Elimination des variables corrélées
elimcor_sansY<-function(X,s=0.95){
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
pockets = pockets[,c(elimcor_sansY(pockets[,-37], 0.6)$possetap, 37)]
pockets
glm(pockets[,37] ~ ., data= pockets[,-37], family="binomial")
glm(pockets[,27] ~ ., data= pockets[,-27], family="binomial")
glm(pockets[,27] ~ ., data= pockets[,-27], family="binomial")
plot(cars)
pockets = read.table("descriptor_pocket.mat")
names(pockets)
dim(pockets)
#is.na(pockets)
pockets = na.omit(pockets)
dim(pockets)
aromatic = apply(cbind(pockets$F, pockets$Y, pockets$H, pockets$W), 1, sum)
polar = apply(cbind(pockets$C, pockets$D, pockets$E, pockets$H, pockets$K, pockets$N, pockets$Q, pockets$R, pockets$S, pockets$T, pockets$W, pockets$Y), 1, sum)
aliphatic = apply(cbind(pockets$I, pockets$L, pockets$V), 1, sum)
charged = apply(cbind(pockets$D, pockets$E, pockets$R, pockets$K, pockets$H), 1, sum)
negative = apply(cbind(pockets$D, pockets$E), 1, sum)
positive = apply(cbind(pockets$R, pockets$K, pockets$H), 1, sum)
hydrophobic = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$L, pockets$I, pockets$M, pockets$F, pockets$W, pockets$H, pockets$Y, pockets$K), 1, sum)
small = apply(cbind(pockets$C, pockets$G, pockets$A, pockets$T, pockets$V, pockets$S, pockets$D, pockets$N, pockets$P), 1, sum)
tiny = apply(cbind(pockets$A, pockets$C, pockets$G, pockets$S), 1, sum)
pockets = cbind(pockets, aromatic, polar, aliphatic, charged, negative, positive, hydrophobic, small, tiny)
#mise de "drugg" à la fin du tableau
noms = names(pockets)
pockets = cbind(pockets[,1:27], pockets[,29:37], pockets[,28])
colnames(pockets)[37] = noms[28]
names(pockets)   #37 descriptors
boxplot(scale(pockets[,-37]), las=2)
#ma version
hist(pockets$polar[pockets$drugg == 1], freq=F, col = "purple", xlim = c(0, 1))
hist(pockets$polar[pockets$drugg == 0], freq=F, col =rgb(1,0,0,0.5), add=T)
#version prof
# par(mfrow = c(1, 2))
# for (i in c(1:36))
#     by(pockets[,i], pockets$drugg, hist, main = "un histogramme")
#ma version
# for (i in 1:36){
#     print(mean(pockets[,i][pockets$drugg == 1]))
#     print(mean(pockets[,i][pockets$drugg == 0]))
#     print(sd(pockets[,i][pockets$drugg == 1]))
#     print(sd(pockets[,i][pockets$drugg == 0]))
# }
#version prof
# lapply(pockets, mean)
# lapply(pockets, sd)
print(means <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = mean))
print(sds <- aggregate(pockets[,-37], by=list(pockets$drugg), FUN = sd))
pockets.pvalues = c()
for (i in 1:36){
# Optionnel, il faudrait comparer les variances, comme condition d'application du Student
#    var.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])
pvalue = t.test(pockets[,i][pockets$drugg == 1], pockets[,i][pockets$drugg == 0])$p.value
pockets.pvalues = c(pockets.pvalues, pvalue)
}
pockets.pvalues
drug.corr = cor(pockets[,-37])
library(corrplot)
corrplot(drug.corr)
# plot(pockets$polar, pockets$hydrophobic)
# plot(pockets$Real_volume, pockets$C_ATOM)
pockets.dist = dist(scale(pockets[,-37]))
# donne un matrice triangulaire inférieure de la distance de tous les résidus 2 à 2
pockets.tree = hclust(pockets.dist, method = "ward.D2")
plot(pockets.tree, hang=-1, labels = pockets$drugg, xlab = "Poches (1 = druggable, 0 = non-druggable)", ylab = "Distance", main = "Dendrogramme par la m?thode de Ward")
rect.hclust(pockets.tree, k = 5, border = "red")
# rect.hclust(pockets.tree, k = 6, border = "red")
# rect.hclust(pockets.tree, k = 8, border = "red")
pockets.kmeans = kmeans(pockets[, -37], centers = 3)
pockets.kmeans$cluster
plot(hclust(pockets.dist), hang = -1, labels = as.factor(pockets.kmeans$cluster))
I.intra = rep(0, 10)
I.intra
for (i in 1:length(I.intra)){
I.intra[i] = kmeans(pockets, centers = i)$tot.withinss
}
plot(I.intra, type = "l", xlab = "Nombre de clusters", ylab = "Inertie intra-classe", main = "D?termination du nombre de cluster id?al par la m?thode des kmeans")
abline(v=3, col = "red")
text(3, 40000000, "3 clusters", col = "red")
library(FactoMineR)
pockets.acp12 = PCA(pockets, ncp = 5, axes=c(1, 2))
plot(pockets.acp12, choix = "ind", col.ind = (pockets[,37]+1), title = "NOIRS = non-druggables // ROUGES = druggables")
pockets.acp34 = PCA(pockets, ncp = 5, axes=c(3, 4))
# dimension 1 : SMALL + TINY // AROMATIC
# dimension 2 : POLAR + CHARGED // HYDROPHOBIC + ALIPHATIC
# dimension 3 : C_RESIDUES + C_ATOM + REAL_VOLUME // MEAN_ALPHA.SPHERE_SA + MEAN_ALPHA.SPHERE_RADIUS
barplot(pockets.acp12$eig[,1], main="valeurs propres", names.arg=1:nrow(pockets.acp12$eig))
barplot(pockets.acp12$eig[,3], main="Somme cumulé des variances")
#Couleurs des individus en fonctions des clusters
pockets.kmeans = kmeans(scale(pockets[, -37]), centers = 5)
plot(pockets.acp12, choix = "ind", col.ind = pockets.kmeans$cluster)
#Elimination des variables corrélées
elimcor_sansY<-function(X,s=0.95){
#X matrice contenant les variables à grouper
#Y vecteur contenant les groupes à prédire
#s valeur seuil de corrélation
correl=cor(X)
stop=F
possetap=1:ncol(X)
groupes=as.list(1:ncol(X))
while (stop==F)
{
##regroupement des var pour lesquelles |corr|>0.95
gplist<-list(NULL)
possglob=1:ncol(correl)
for (i in 1:(ncol(correl)))
{
poss=possglob[-i]
gplist[[i]]=c(i,poss[abs(correl[i,poss])>s])
}
##on trie les groupes du plus gros au plus petit
gplisteff=unlist(lapply(gplist,length))
if (any(gplisteff>1))
{
gplistfin=gplist[gplisteff>1]
gplistuniq=unlist(gplist[gplisteff==1])
gpsel=NULL
##on sélectionne dans chaque groupe une variable au hasard
for (i in 1:length(gplistfin))
{
selloc=min(gplistfin[[i]])
gploc=groupes[[possetap[selloc]]]
for (j in 1:length(gplistfin[[i]]))
{
gploc=c(gploc,groupes[[possetap[gplistfin[[i]][j]]]])				    }
groupes[[possetap[selloc]]]=unique(gploc)
gpsel=c(gpsel,selloc)
}
possetap=possetap[c(gplistuniq,unique(gpsel))]
correl=cor(X[,possetap])
}
else stop=T
}
#groupeseff=unlist(lapply(groupes,length))
#groupes=groupes[groupeseff>1]
return(list(possetap=possetap,groupes=groupes))
}
pockets = pockets[,c(elimcor_sansY(pockets[,-37], 0.6)$possetap, 37)]
dim(pockets)
glm(pockets[,27] ~ ., data= pockets[,-27], family="binomial")
glm(pockets[,27] ~ ., data= pockets[,-27], family="binomial")
pockets.glm = glm(pockets[,27] ~ ., data= pockets[,-27], family="binomial")
summary(pockets.glm)
pockets.glm.pvalue = pockets.glm$coefficients[[2,4]]
pockets.glm
summary(pockets.glm)
class(summary(pockets.glm))
class(summary(pockets.glm))
class(summary(pockets.glm)$coefficients)
summary(pockets.glm)$coefficients
summary(pockets.glm)$coefficients[[2,4]]
summary(pockets.glm)$coefficients
summary(pockets.glm)$coefficients[2,4]
